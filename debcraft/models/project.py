#  This file is part of debcraft.
#
#  Copyright 2025 Canonical Ltd.
#
#  This program is free software: you can redistribute it and/or modify it
#  under the terms of the GNU General Public License version 3, as
#  published by the Free Software Foundation.
#
#  This program is distributed in the hope that it will be useful, but WITHOUT
#  ANY WARRANTY; without even the implied warranties of MERCHANTABILITY,
#  SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Package metadata for Debcraft."""

import enum
import re
from typing import Annotated

import pydantic
from craft_application import models
from typing_extensions import Self

from debcraft import errors
from debcraft.models.package import Package

DEBIAN_PACKAGE_NAME_REGEX = r"^[a-z0-9][a-z0-9.+-]+$"
"""A regular expression to implement Debian package name rules.

Based on the rules provided at:
https://www.debian.org/doc/debian-policy/ch-controlfields.html#s-f-source
"""


def _validate_debian_package_name(name: str) -> str:
    """Validate a Debian package name."""
    if not re.fullmatch(DEBIAN_PACKAGE_NAME_REGEX, name):
        raise ValueError(
            "package names must consist only of lower case letters (a-z), digits "
            "(0-9), plus (+) and minus (-) signs, and periods (.). They must be at "
            "least two characters long and must start with an alphanumeric character."
        )
    return name


DebianPackageName = Annotated[
    str,
    pydantic.Field(min_length=2, pattern=DEBIAN_PACKAGE_NAME_REGEX),
    pydantic.BeforeValidator(_validate_debian_package_name),
]


class Priority(enum.Enum):
    """Priority for a deb package."""

    REQUIRED = "required"
    IMPORTANT = "important"
    STANDARD = "standard"
    OPTIONAL = "optional"
    # Extra is deprecated, so not included.


class Project(models.Project):
    """Debcraft project definition."""

    name: DebianPackageName
    """The name of the source package."""
    # contact -> Maintainer
    # source-code -> Vcs-Browser
    priority: Priority = Priority.OPTIONAL
    # Maintainer validation: https://github.com/canonical/debcraft/issues/39
    maintainer: str
    original_maintainer: str | None = None
    uploaders: list[str] | None = None

    # Standards-Version is generated by debcraft.
    # Build-Depends is generated by the sum of `build-packages` from parts.
    # Build-Depends-Arch is generated with build-packages with grammar.
    # Build-Conflicts etc. are only added through passthrough.

    section: str | None = None

    # Passed directly to the source package.
    passthrough: dict[str, str] = pydantic.Field(default_factory=dict)
    """Values that are passed directly into the control stanza for the source package.

    Use of this key indicates something incomplete in debcraft.
    """

    packages: dict[DebianPackageName, Package] | None = None
    """A mapping of binary package names to their control fields."""

    @pydantic.model_validator(mode="after")
    def _validate_adopt_info_part_exists(self) -> Self:
        if self.adopt_info and self.adopt_info not in self.parts:
            raise ValueError("'adopt-info' field must refer to the name of a part.")
        return self

    def get_package(self, name: str) -> Package:
        """Obtain the package definition for the given package name."""
        if not self.packages:
            raise errors.DebcraftError("no packages defined")

        package = self.packages.get(name)
        if not package:
            raise errors.DebcraftError(f"package {name} is not defined")

        return package


class PackagesProject(models.CraftBaseModel, extra="ignore"):
    """Project definition containing only package data."""

    packages: dict[DebianPackageName, Package] | None = None

    def get_partitions(self) -> list[str] | None:
        """Get a list of partitions based on the project's packages.

        :returns: A list of packages formatted as ['default', 'package/<name>', ...]
        """
        partitions = ["default"]

        if self.packages:
            partitions.extend([f"package/{name}" for name in self.packages])

        return partitions
